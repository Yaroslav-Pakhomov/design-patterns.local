Декоратор
Decorator

Декоратор - структурный шаблон проектирования, который позволяет расширить функциональность объектов за счет "оборачивания" их в "декораторы" и изменяют поведение изначального класса. Причем не за счет наследования от базового класса, а именно за счет агрегирования или композиции этого самого класса в "декораторах".

Об этот шаблон я сломал себе голову, потому что с самого начала запутался в классах, определениях и наследованиях, но в итоге разобрался (скорее всего). Теперь, как смогу, разжую инсайт, относительно этого шаблона на примере уведомлений.

1. Создадим интерфейс INotifier.

2. У нас есть класс SimpleNotification, который мы прокачаем декораторами, реализующий интерфейс INotifier.
И собственно объекты класса SimpleNotification вполне себе обыденно выполняют свою простую работу - возвращают переданное в них текстовое сообщение. А теперь начинается магия декорирования.


-----------------------------------------
Внезапно, нам потребовалось отправлять уведомления разнообразными способами, и мы бы могли просто унаследовать от этого класса ворох потомков и использовать их! Но тут мы собрались не ради очевидных решений, а ради шаблонов проектирования! За сим, для того чтобы добавить поведения классу и не заниматься наследованием этого класса, будем мутить "декораторы", на основе интерфейса класса простого уведомления.
-----------------------------------------


3. Создадим базовый класс-уведомитель, в котором передадим в конструктор простое уведомление и будем использовать его в реализации метода notify().

4. Наследуя конкретные декораторы от базового, наплодим сущностей - начнем с электронной почты класс EmailNotifier, продолжим Телеграммом класс TelegramNotifier, остановимся на СМС класс SMSNotifier.


-----------------------------------------
Каждый из конкретных декораторов будет добавлять некий свой функционал и вызывать родительский метод notify(), который в свою очередь вызывает метод notify() у агрегированного объекта. Для меня цепочка оказалась сложна и запутана, видимо в силу природной несообразительности, надеюсь для вас понять, осознать и принять будет проще. Благодаря клиентскому коду ситуация может проясниться.
-----------------------------------------



Ещё пример (папка «Coffee»):
В отличие от статического механизма наследования, паттерн Decorator работает динамически. Он может добавлять объектам необходимую функциональность в процессе.

Рассмотрим в качестве примера кофе.

1. Прежде всего, у нас есть простой кофе класс SimpleCoffee с соответствующим интерфейсом ICoffee.

2. Теперь мы хотим добавить дополнительные параметры создаём классы MilkCoffee, WhipCoffee, VanillaCoffee, в которые передаём наш базовый класс SimpleCoffee.

3. Теперь сделаем наш кофе.
